import '@nomicfoundation/hardhat-ethers'
import { loadFixture, IFixture } from './fixture'
import { expect } from 'chai'
import { formatEther, parseEther } from 'ethers'
import { time } from '@nomicfoundation/hardhat-toolbox/network-helpers'
import { deployNewCDP, openTrove } from './utils'
import { ethers } from 'hardhat'

describe('Test TroveManager', () => {
	let fixture: IFixture

	beforeEach(async () => {
		fixture = await loadFixture()
	})

	it('batchLiquidate with redistribute', async () => {
		const { signers, BorrowerOperations, accounts, MockCollateralToken, MockPriceFeed, DebtToken } = fixture
		const price = parseEther('100000')
		const troveManager = await deployNewCDP(fixture, { spYieldPCT: 0n }, { collateralToken: MockCollateralToken.target })
		const MCR = await troveManager.MCR()
		const { id: id0 } = await openTrove(fixture, { debt: parseEther('4800'), coll: parseEther('1'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const { id: id1 } = await openTrove(fixture, { debt: parseEther('49800'), coll: parseEther('2'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const { id: id2 } = await openTrove(fixture, { debt: parseEther('79800'), coll: parseEther('1'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const { id: id3 } = await openTrove(fixture, { debt: parseEther('80800'), coll: parseEther('1'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const TCR = await troveManager.getTCR.staticCall()
		// console.log('TCR', formatEther(TCR))
		const ICR0 = await troveManager.getCurrentICR(id0, price)
		const ICR1 = await troveManager.getCurrentICR(id1, price)
		const ICR2 = await troveManager.getCurrentICR(id2, price)
		const ICR3 = await troveManager.getCurrentICR(id3, price)
		// console.log('ICR0', formatEther(ICR0), 'ICR1', formatEther(ICR1), 'ICR2', formatEther(ICR2), 'ICR3', formatEther(ICR3))
		const newPrice = parseEther('96000')
		await MockPriceFeed.updatePrice(MockCollateralToken.target, newPrice)
		const NewTCR = await troveManager.getTCR.staticCall()
		// console.log('NewTCR', formatEther(NewTCR))
		const NewICR0 = await troveManager.getCurrentICR(id0, newPrice)
		const NewICR1 = await troveManager.getCurrentICR(id1, newPrice)
		const NewICR2 = await troveManager.getCurrentICR(id2, newPrice)
		const NewICR3 = await troveManager.getCurrentICR(id3, newPrice)
		// console.log('NewICR0', formatEther(NewICR0), 'NewICR1', formatEther(NewICR1), 'NewICR2', formatEther(NewICR2), 'NewICR3', formatEther(NewICR3))
		expect(NewICR2).to.be.lt(MCR)
		expect(NewICR3).to.be.lt(MCR)
		await troveManager.connect(signers[3]).batchLiquidate([id2, id3])
		const balanceCollateral = await MockCollateralToken.balanceOf(accounts[3])
		const balanceDebtToken = await DebtToken.balanceOf(accounts[3])
		expect(balanceCollateral).to.be.eq(parseEther('0.01'))
		expect(balanceDebtToken).to.be.eq(parseEther('400'))
		const collSurplus = await troveManager.accountCollSurplus(accounts[0])
		expect(collSurplus).to.be.gt(0n)
		await expect(troveManager.claimCollSurplus(accounts[1], collSurplus)).to.be.reverted
		await troveManager.claimCollSurplus(accounts[0], collSurplus)
		// close all trove with all received interest
		await troveManager.setApprovalForAll(accounts[2], true)
		const totalReceived = await DebtToken.balanceOf(accounts[0])
		await DebtToken.transfer(accounts[2], totalReceived)
		await DebtToken.connect(signers[3]).transfer(accounts[2], balanceDebtToken)
		await BorrowerOperations.connect(signers[2]).closeTrove(troveManager.target, id0, accounts[0])
		await BorrowerOperations.connect(signers[2]).closeTrove(troveManager.target, id1, accounts[0])
	})

	it('batchLiquidate with stability pool offset', async () => {
		const { signers, BorrowerOperations, StabilityPool, accounts, MockCollateralToken, MockPriceFeed, DebtToken } = fixture
		const price = parseEther('100000')
		const troveManager = await deployNewCDP(fixture, undefined, { collateralToken: MockCollateralToken.target })
		const MCR = await troveManager.MCR()
		const _100PCT = await troveManager.DECIMAL_PRECISION()
		const { id: id0 } = await openTrove(fixture, { debt: parseEther('4800'), coll: parseEther('1'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const { id: id1 } = await openTrove(fixture, { debt: parseEther('49800'), coll: parseEther('2'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const { id: id2 } = await openTrove(fixture, { debt: parseEther('79800'), coll: parseEther('1'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const { id: id3 } = await openTrove(fixture, { debt: parseEther('80800'), coll: parseEther('1'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const TCR = await troveManager.getTCR.staticCall()
		// console.log('TCR', formatEther(TCR))
		const ICR0 = await troveManager.getCurrentICR(id0, price)
		const ICR1 = await troveManager.getCurrentICR(id1, price)
		const ICR2 = await troveManager.getCurrentICR(id2, price)
		const ICR3 = await troveManager.getCurrentICR(id3, price)
		// console.log('ICR0', formatEther(ICR0), 'ICR1', formatEther(ICR1), 'ICR2', formatEther(ICR2), 'ICR3', formatEther(ICR3))
		const newPrice = parseEther('96000')
		await MockPriceFeed.updatePrice(MockCollateralToken.target, newPrice)
		const NewTCR = await troveManager.getTCR.staticCall()
		// console.log('NewTCR', formatEther(NewTCR))
		const NewICR0 = await troveManager.getCurrentICR(id0, newPrice)
		const NewICR1 = await troveManager.getCurrentICR(id1, newPrice)
		const NewICR2 = await troveManager.getCurrentICR(id2, newPrice)
		const NewICR3 = await troveManager.getCurrentICR(id3, newPrice)
		// console.log('NewICR0', formatEther(NewICR0), 'NewICR1', formatEther(NewICR1), 'NewICR2', formatEther(NewICR2), 'NewICR3', formatEther(NewICR3))
		expect(NewICR2).to.be.lt(MCR)
		expect(NewICR2).to.be.lt(_100PCT)
		expect(NewICR3).to.be.gt(_100PCT)
		expect(NewICR3).to.be.lt(MCR)
		await StabilityPool.provideToSP(parseEther('100000') + parseEther('91000'))
		await troveManager.connect(signers[3]).batchLiquidate([id3, id2])
		const balanceCollateral = await MockCollateralToken.balanceOf(accounts[3])
		const balanceDebtToken = await DebtToken.balanceOf(accounts[3])
		expect(balanceCollateral).to.be.eq(parseEther('0.01'))
		expect(balanceDebtToken).to.be.eq(parseEther('400'))

	})

	it('batchLiquidate with stability pool offset and redistribute', async () => {
		const { signers, BorrowerOperations, StabilityPool, accounts, MockCollateralToken, MockPriceFeed, DebtToken } = fixture
		const price = parseEther('100000')
		const troveManager = await deployNewCDP(fixture, { liquidationPenaltyRedistribution: parseEther('0.05') }, { collateralToken: MockCollateralToken.target })
		const MCR = await troveManager.MCR()
		const _100PCT = await troveManager.DECIMAL_PRECISION()
		const { id: id0 } = await openTrove(fixture, { debt: parseEther('4800'), coll: parseEther('1'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const { id: id1 } = await openTrove(fixture, { debt: parseEther('49800'), coll: parseEther('2'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const { id: id2 } = await openTrove(fixture, { debt: parseEther('79800'), coll: parseEther('1'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const { id: id3 } = await openTrove(fixture, { debt: parseEther('80800'), coll: parseEther('1'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		const TCR = await troveManager.getTCR.staticCall()
		// console.log('TCR', formatEther(TCR))
		const ICR0 = await troveManager.getCurrentICR(id0, price)
		const ICR1 = await troveManager.getCurrentICR(id1, price)
		const ICR2 = await troveManager.getCurrentICR(id2, price)
		const ICR3 = await troveManager.getCurrentICR(id3, price)
		// console.log('ICR0', formatEther(ICR0), 'ICR1', formatEther(ICR1), 'ICR2', formatEther(ICR2), 'ICR3', formatEther(ICR3))
		const newPrice = parseEther('96000')
		await MockPriceFeed.updatePrice(MockCollateralToken.target, newPrice)
		const NewTCR = await troveManager.getTCR.staticCall()
		// console.log('NewTCR', formatEther(NewTCR))
		const NewICR0 = await troveManager.getCurrentICR(id0, newPrice)
		const NewICR1 = await troveManager.getCurrentICR(id1, newPrice)
		const NewICR2 = await troveManager.getCurrentICR(id2, newPrice)
		const NewICR3 = await troveManager.getCurrentICR(id3, newPrice)
		// console.log('NewICR0', formatEther(NewICR0), 'NewICR1', formatEther(NewICR1), 'NewICR2', formatEther(NewICR2), 'NewICR3', formatEther(NewICR3))
		expect(NewICR2).to.be.lt(MCR)
		expect(NewICR2).to.be.lt(_100PCT)
		expect(NewICR3).to.be.gt(_100PCT)
		expect(NewICR3).to.be.lt(MCR)
		await StabilityPool.provideToSP(parseEther('80000') + parseEther('91000') - parseEther('10000'))
		await troveManager.connect(signers[3]).batchLiquidate([id3, id2])
		const balanceCollateral = await MockCollateralToken.balanceOf(accounts[3])
		const balanceDebtToken = await DebtToken.balanceOf(accounts[3])
		expect(balanceCollateral).to.be.eq(parseEther('0.01'))
		expect(balanceDebtToken).to.be.eq(parseEther('400'))
	})

	it('shutdown smoothly', async () => {
		const { MockCollateralToken } = fixture
		const price = parseEther('100000')
		const troveManager = await deployNewCDP(fixture, undefined, { collateralToken: MockCollateralToken.target })
		await openTrove(fixture, { debt: parseEther('4800'), coll: parseEther('1'), price, troveManager })
		await time.increase(24 * 3600 * 365)
		await troveManager.shutdown()
		const totalActiveInterest = await troveManager.totalActiveInterest()
		await time.increase(24 * 3600 * 365)
		await troveManager.accrueInterests()
		const newTotalActiveInterest = await troveManager.totalActiveInterest()
		expect(totalActiveInterest).to.be.equal(newTotalActiveInterest)
	})
})